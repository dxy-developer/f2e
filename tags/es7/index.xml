<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es7 on 丁香园前端小分队</title>
    <link>http://dxy-developer.github.io/f2e/tags/es7/</link>
    <description>Recent content in Es7 on 丁香园前端小分队</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Establishment · 丁香园前端</copyright>
    <lastBuildDate>Mon, 14 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://dxy-developer.github.io/f2e/tags/es7/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ES6 - 解构赋值</title>
      <link>http://dxy-developer.github.io/f2e/article/es6-destructuring/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://dxy-developer.github.io/f2e/article/es6-destructuring/</guid>
      <description>

&lt;p&gt;在解释什么是解构赋值前，我们先来看一下， ES5 中对变量的声明和赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var str = &#39;hello word&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边一个变量名，右边可以是字符串，数组或对象。&lt;/p&gt;

&lt;p&gt;ES6 中增加了一种更为便捷的赋值方式。称为 &lt;strong&gt;Destructuring&lt;/strong&gt; 。好像大家普遍翻译为解构。解构赋值允许我们将数组或对象的属性赋予给任何变量，该变量的定义语法与数组字面量或对象字面量很相似。举个例子可以直观的说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [speak, name] = [&#39;hello&#39;, &#39;destructuring&#39;];
console.log( speak + &#39; &#39; + name ); // hello destructuring
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组的解构赋值:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;数组的解构赋值&lt;/h3&gt;

&lt;p&gt;用更加直白的话来描述就是，等号两边保持相同的形式（数组对应数组，对象对应对象），则左边的变量就会被赋予对应的值。如果对应的右边值缺失，缺失部分变量值为 &lt;code&gt;undefined&lt;/code&gt; ,如果右边值多余，依旧能够正常解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ES6 中
let arr = [1,2,3,4,5];
let [el1, el2] = [arr];
// 或者
let [el1, el2] = [1,2,3,4,5];
// el1 =&amp;gt; 1, el2 =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构赋值也是可嵌套的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let value = [1, 2, [3, 4, 5]];
let [el1, el2, [el3, el4]] = value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样可以通过简单地在指定位置省略变量来忽略数组中的某个元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let value = [1, 2, 3, 4, 5];
let [el1, , el3, , el5] = value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更进一步，默认值同样也可以被指定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [firstName = &amp;quot;John&amp;quot;, lastName = &amp;quot;Doe&amp;quot;] = [];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES6中，提供了一种将右侧多余的值以数组的形式赋值给左侧变量的语法——“rest“模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [head, ...tail] = [1, 2, 3, 4];
console.log(tail);  // [2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当默认值不存在，变量值就等于 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [missing] = [];
console.log(missing);  // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的数组，指的是部署了 &lt;code&gt;[Iterator](http://www.2ality.com/2015/02/es6-iteration.html)&lt;/code&gt; 接口的数据结构。&lt;/p&gt;

&lt;h3 id=&#34;对象的解构赋值:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;对象的解构赋值&lt;/h3&gt;

&lt;p&gt;和数组的用法相类似，一个主要的不同点是，对象是无次序排列的，所以变量必须和属性名相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let person = {firstName: &amp;quot;John&amp;quot;, lastName: &amp;quot;Doe&amp;quot;};
let {firstName, lastName} = person;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构另一个特性是，变量 keys 可以使用&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&#34;&gt;计算后的属性名&lt;/a&gt;，但是如果你对这容易混淆的话，不建议使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let person = {firstName: &amp;quot;John&amp;quot;, lastName: &amp;quot;Doe&amp;quot;};
let {firstName: name, lastName} = person;
// `name`变量将会被声明为 `person.firstName` 的值
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数参数的解构赋值:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;函数参数的解构赋值&lt;/h3&gt;

&lt;p&gt;函数的参数也可以解构赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add({x: 0, y: 0}){
    return x+y;
}
add({1,2}); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;null-和-undefined:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;null 和 undefined&lt;/h3&gt;

&lt;p&gt;当尝试解构 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的时候会报错。这是因为使用对象赋值模式时，被解构的值必需能够转换成一个对象（object）。大多数的类型都可以转换为一个对象，但null和undefined却并不能被转换。&lt;/p&gt;

&lt;h3 id=&#34;其它:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;其它&lt;/h3&gt;

&lt;p&gt;解构赋值的好处有很多，比如&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个值的交换&lt;/li&gt;
&lt;li&gt;函数参数默认值&lt;/li&gt;
&lt;li&gt;函数返回值&lt;/li&gt;
&lt;li&gt;正则匹配的返回值&lt;/li&gt;
&lt;li&gt;快速处理 JSON 数据&lt;/li&gt;
&lt;li&gt;遍历Map结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ES6 的解构赋值给 JS 的书写带来了很大的便利性，同时也提高了代码的可读性。但是也需要注意一些问题，避免适得其反。
* 关于圆括号的问题，欢迎翻看&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/destructuring#圆括号问题&#34;&gt;阮一峰老师的博客&lt;/a&gt;
* 解构的嵌套尽量不要太深
* 函数有多个返回值时，尽量使用对象解构而不用数组解构，避免出现顺序对应问题
* 已声明过的变量不能用于解构&lt;/p&gt;

&lt;h3 id=&#34;浏览器支持:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;浏览器支持&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://kangax.github.io/compat-table/es6/#destructuring&#34;&gt;http://kangax.github.io/compat-table/es6/#destructuring&lt;/a&gt;
不完全统计：
* IE NO
* FF 38+ (大部分)
* CH/OP NO
* Webkit
* SF 9+, 8部分
* IOS8 部分&lt;/p&gt;

&lt;p&gt;PS: 整理的时候发现以前还保留着这样一份文章，无新，基本参考下述文章内容。仅供学习。&lt;/p&gt;

&lt;h3 id=&#34;参考文章:e302e6c8f79de556a21c4ad066a4fea9&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/destructuring&#34;&gt;变量的解构赋值 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/&#34;&gt;ES6 In Depth: Destructuring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/strongblog/getting-started-with-javascript-es6-destructuring/&#34;&gt;Getting Started with JavaScript ES6 Destructuring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>